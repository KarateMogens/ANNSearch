/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package lsh;

import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.lang.reflect.Method;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Scanner;
import java.util.stream.Collectors;

import java.util.Arrays;

import ch.systemsx.cisd.hdf5.*;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;


public class App {

    private static final Logger logger = LogManager.getLogger(App.class);
    
    Map<String, Method> datastructures;
    ANNSearcherFactory factory = ANNSearcherFactory.getInstance();
    Properties configProperties;
    float[][] test;
    int[][] neighbors;
    float[][] train;

    public App(String configFilePath) {

        logger.info("Starting application");

        // Load config gile
        configProperties = new Properties();
        try {
            configProperties.load(new FileInputStream(new File(configFilePath)));
            logger.info("Successfully loaded configfile: " + configFilePath);
        } catch (IOException e){
            logger.error(".properties file not found");
        }

        // Check if corpus file exists
        String datasetFilePath = getProperty("datasetPath");
        if (!Utils.fileExists(datasetFilePath)) {
            logger.error("No dataset file located at the specified directory: " + datasetFilePath);
            return;
        }
        
        // Load dataset file
        IHDF5Reader reader = HDF5FactoryProvider.get().openForReading(new File(datasetFilePath));
        test = reader.readFloatMatrix("test");
        neighbors = reader.readIntMatrix("neighbors");
        train = reader.readFloatMatrix("train");
        reader.close();

        String metric = getProperty("metric");

        if (metric.equals("angular")) {
            train = Utils.normalizeCorpus(train);
            test = Utils.normalizeCorpus(test);
        }
    }

    private void runBenchmarks() {

        factory.setDataset(configProperties.getProperty("datasetPath"), getProperty("metric"), train);
    
        MicroBenchmark benchmark = new MicroBenchmark();

        String datastructure = getProperty("datastructure");
        String[] datastructureArgs = getPropertyList("datastructureArgs");
        String searchStrategy = getProperty("searchStrategy");
        String[] searchStrategyArgs = getPropertyList("searchStrategyArgs");  

        for (String datastructureArgList : datastructureArgs) {

            String[] args = getArgs(datastructureArgList);
            ANNSearcher searcher = getSearcher(datastructure, args);
            if (searcher == null) {
                continue;
            }

            // //To focus profiling
            // Scanner myScanner = new Scanner(System.in);
            // logger.info("Ready for profiling");
            // int myint = myScanner.nextInt();

            for (String searchStrategyArgsList : searchStrategyArgs) {
                String[] strategyArgs = getArgs(searchStrategyArgsList);
                logger.info("Benchmarking: " + datastructure + " " + Arrays.toString(args) + " - " + searchStrategy + " " + Arrays.toString(strategyArgs));

                MicroBenchmark.Results results = null;
                switch (searchStrategy) {
                    case "lookupSearch":
                        results = benchmark.benchmark(searcher, test, searchStrategy, Integer.parseInt(strategyArgs[0]));
                        break;
                    case "votingSearch":
                        results = benchmark.benchmark(searcher, test, searchStrategy, Integer.parseInt(strategyArgs[0]), Integer.parseInt(strategyArgs[1]));
                        break;
                    case "naturalClassifierSearch":
                        results = benchmark.benchmark(searcher, test, searchStrategy, Integer.parseInt(strategyArgs[0]), Float.parseFloat(strategyArgs[1]));
                        break;
                    case "naturalClassifierSearchRawCount":
                        results = benchmark.benchmark(searcher, test, searchStrategy, Integer.parseInt(strategyArgs[0]), Integer.parseInt(strategyArgs[1]));
                        break;
                    case "naturalClassifierSearchSetSize":
                        results = benchmark.benchmark(searcher, test, searchStrategy, Integer.parseInt(strategyArgs[0]), Integer.parseInt(strategyArgs[1]));
                        break;
                    case "bruteForceSearch":
                        results = benchmark.benchmark(searcher, test, searchStrategy, Integer.parseInt(strategyArgs[0]));
                        break;
                    default:
                        logger.error("Error calling search strategy: " + searchStrategy + ". Search strategy is not valid");
                        continue;
                }
                System.out.println("\n" + datastructure + " " + Arrays.toString(args) + " - " + searchStrategy + " " + Arrays.toString(strategyArgs));
                printStats(results);
                writeResults(results, datastructure, args, searchStrategy, strategyArgs);
            }
        }
    }


    private ANNSearcher getSearcher(String datastructure, String[] args) {
        // Return the ANNSearch object based on arguments from config file
        try {
            switch (datastructure) {
                case "RKDTree":
                    return factory.getNCTreeSearcher(Integer.parseInt(args[0]), Integer.parseInt(args[1]), "RKD", Integer.parseInt(args[2]));
                case "RPTree":
                    return factory.getNCTreeSearcher(Integer.parseInt(args[0]), Integer.parseInt(args[1]), "RP", Integer.parseInt(args[2]));
                case "LSH":
                    return factory.getNCLSHSearcher(Integer.parseInt(args[0]), Float.parseFloat(args[1]), Integer.parseInt(args[2]), Integer.parseInt(args[3]));
                case "C2LSH":
                    return factory.getNCC2LSHSearcher(Integer.parseInt(args[0]), Integer.parseInt(args[1]),  Integer.parseInt(args[2]), Integer.parseInt(args[3]), Integer.parseInt(args[4]));
            }   
        } catch (FileNotFoundException e) {
            logger.error("Error getting datastructure: " + datastructure + "with arguments: " + Arrays.toString(args));
        }
        return null;
    }


    private String[] getArgs(String argsString) {
        return argsString.trim().split(" +");
    }

    private String getProperty(String key) {
        return configProperties.getProperty(key).trim();
    }

    private String[] getPropertyList(String key) {
        return getProperty(key).split(";");
    }

    private void printStats(MicroBenchmark.Results results) {
        results.statistics();
        System.out.println("Mean: " + results.getMeanQueryTime());
        System.out.println("Std. dev: " + results.getStandardDeviation());
        System.out.println("Max: " + results.getMaxTime());
        System.out.println("Min: " + results.getMinTime());
        
        //Calculate recall
        int[][] neighborsFound = results.getNeighbors();
        float[] recalls = new float[neighborsFound.length];
        for (int i = 0; i < neighborsFound.length; i++) {
            float recall = 0;
            List<Integer> trueNeighbors = Arrays.stream(neighbors[i])     // IntStream
                         .boxed()             // Stream<Integer>
                         .collect(Collectors.toList());
            for (int j = 0; j < neighborsFound[i].length; j++) {
                if (trueNeighbors.contains(neighborsFound[i][j])) {
                    recall += 1.0f;
                }
            }
            recalls[i] = recall / neighborsFound[i].length;
        }
        System.out.println("Mean recall: " + Utils.mean(recalls));
    }

    private void writeResults(MicroBenchmark.Results results, String datastructure, String[] datastructureArgs, String searchStrategy, String[] searchStrategyArgs) {
        logger.trace("Writing benchmarking results to .hdf5");;
        String identifier = createIdentifier(datastructure, datastructureArgs, searchStrategy, searchStrategyArgs);
        File resultsFile = createHDF5(results, identifier);
        IHDF5SimpleWriter writer = HDF5FactoryProvider.get().open(resultsFile);
        writer.writeIntMatrix("neighbors", results.getNeighbors());
        writer.writeFloatMatrix("distances", results.getDistances());
        writer.writeFloatArray("times", results.getQueryTimes());
        
    }

    private String createIdentifier(String datastructure, String[] datastructureArgs, String searchStrategy, String[] searchStrategyArgs) {
        StringBuilder builder = new StringBuilder();
        builder.append(datastructure);
        for (String arg : datastructureArgs) {
            builder.append(arg);
            builder.append("_");
        }
        builder.append(searchStrategy);
        for (String arg : searchStrategyArgs) {
            builder.append(arg);
            builder.append("_");
        }
        builder.deleteCharAt(builder.length()-1);
        return builder.toString();
    }

    private File createHDF5(MicroBenchmark.Results results, String identifier) {
        String datasetFilePath = getProperty("datasetPath");
        datasetFilePath = datasetFilePath.substring(0, datasetFilePath.lastIndexOf("/") + 1);
        File resultsFile = new File(datasetFilePath + identifier + ".hdf5");
        try {   
            resultsFile.createNewFile();
            return resultsFile;
        } catch (IOException exception) {
            logger.error("There was an error creating a results file for the benchmark");
            return null;
        }
    }

    public static void main(String[] args) {

        //Switch for jar compilation or running through IDE
        App myApp = new App("app/src/main/resources/config.properties");
        //App myApp = new App(args[0]);

        myApp.runBenchmarks();
        logger.info("Terminating application");

        
    }
}
